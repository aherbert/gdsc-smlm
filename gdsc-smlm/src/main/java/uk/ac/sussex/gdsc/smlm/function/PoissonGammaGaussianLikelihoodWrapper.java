/*-
 * #%L
 * Genome Damage and Stability Centre SMLM Package
 *
 * Software for single molecule localisation microscopy (SMLM)
 * %%
 * Copyright (C) 2011 - 2023 Alex Herbert
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */

package uk.ac.sussex.gdsc.smlm.function;

/**
 * This is a wrapper for any function to compute the negative log-likelihood assuming a
 * Poisson-Gamma-Gaussian distribution.
 *
 * <p>For each observed value the log-likelihood is computed from the Poisson-Gamma-Gaussian
 * distribution (a Poisson convolved with a Gamma distribution convolved with a Gaussian). The
 * Poisson-Gamma distribution is derived analytically in the paper Ulbrich &amp; Isacoff (2007).
 * Nature Methods 4, 319-321 to explain the probability distribution of ADUs given a fixed photon
 * level per pixel and set gain in an EM-CCD camera (The Poisson distribution models the photon
 * count and the Gamma distribution models the EM-gain). This is then numerically convolved with a
 * Gaussian distribution to model the read noise of the camera.
 *
 * <p>The distribution of Ulbrich &amp; Isacoff has no analytical solution to the convolution with a
 * Gaussian. However the convolution with a Gaussian has the most effect when the counts are low.
 * The Poisson-Gamma-Gaussian can be approximated using the Poisson-Gamma and a partial convolution
 * with a Gaussian at low counts. This method is provided as Python source code within the
 * supplementary information of the paper Mortensen, et al (2010) Nature Methods 7, 377-383. This
 * Java implementation is based on the Python code.
 *
 * <p>The mean of the Poisson distribution is set using the expected value generated by the provided
 * function. The scale (EM-gain) for the Gamma distribution and standard deviation of the Gaussian
 * is fixed and set in the constructor. The mean of the Gaussian is assumed to be zero.
 *
 * <p>The negative log-likelihood can be evaluated over the entire set of observed values or for a
 * chosen observed value.
 */
public class PoissonGammaGaussianLikelihoodWrapper extends LikelihoodWrapper {
  private final PoissonGammaGaussianFunction pgg;

  /**
   * Initialise the function.
   *
   * <p>The input parameters must be the full parameters for the non-linear function. Only those
   * parameters with gradient indices should be passed in to the functions to obtain the value (and
   * gradient).
   *
   * @param function The function to be used to calculated the expected values (if modelling EMCCD
   *        data this should evaluate the value without the bias)
   * @param parameters The initial parameters for the function
   * @param data The observed values (if using EMCCD data the bias should be subtracted)
   * @param dataSize The number of observed values
   * @param alpha Inverse gain of the EMCCD chip
   * @param sd The Gaussian standard deviation at readout
   */
  public PoissonGammaGaussianLikelihoodWrapper(NonLinearFunction function, double[] parameters,
      double[] data, int dataSize, double alpha, double sd) {
    super(function, parameters, data, dataSize);
    pgg = new PoissonGammaGaussianFunction(alpha, sd);
  }

  @Override
  public double computeLikelihood() {
    // Compute the negative log-likelihood
    double ll = 0;
    for (int i = 0; i < dataSize; i++) {
      ll -= pgg.logLikelihood(data[i], function.eval(i));
    }
    return ll;
  }

  @Override
  public double computeLikelihood(int index) {
    return -pgg.logLikelihood(data[index], function.eval(index));
  }

  @Override
  public boolean canComputeGradient() {
    return false;
  }
}
